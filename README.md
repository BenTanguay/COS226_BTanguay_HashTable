Reflection

Of the 6 different Hash Functions that I designed, each of them had its own pros and cons. This makes it really hard to determine if there is anyone better than the others. I think that they each would be best suited in situations depending on what is the goal of the table, and what resources are expensive. In the case where pure time is the goal, Table 2 was by far the fastest, although it used up a lot of space. If minimizing the storage space required was the goal, then functions 5 and 6 do that really well, but at the expense of time, with 6 taking the longest, but having the fewest collisions, which means that it will be accessing the data the least, which can be important when the cost of reading data is high, such as in a system with slower storage devices such as hard drives. Overall, each of the approaches tried to learn from the previous ones and improve; even if they didn't achieve the goal of being better than previous versions, they at least taught about what helps and hurts in a hash function.